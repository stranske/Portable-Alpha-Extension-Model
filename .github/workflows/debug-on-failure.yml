# .github/workflows/debug-on-failure.yml
name: Trigger Codex debug on CI failure

on:
  workflow_run:
    workflows: ["CI/CD Pipeline"]
    types: [completed]

permissions:
  actions: write         # to dispatch the debug workflow
  issues: write          # to comment on the PR
  pull-requests: read    # to read PR metadata
  contents: read         # minimal read for repo info

jobs:
  run-debug:
    # Only when the CI pipeline failed on a PR
    if: ${{ github.event.workflow_run.conclusion == 'failure' && github.event.workflow_run.event == 'pull_request' }}
    runs-on: ubuntu-latest

    # Optional override via repo variable; falls back to codex-auto-debug.yml
    env:
      DEBUG_WORKFLOW_FILE: ${{ vars.DEBUG_WORKFLOW_FILE }}
      DEFAULT_DEBUG_WORKFLOW_FILE: codex-auto-debug.yml

    steps:
      - name: Dispatch Codex Auto-Debug from default branch
        uses: actions/github-script@v7
        with:
          script: |
            const run = context.payload.workflow_run;
            if (!run.pull_requests || !run.pull_requests.length) {
              core.info("No pull requests associated with this workflow run. Exiting.");
              return;
            }

            const owner = context.repo.owner;
            const repo  = context.repo.repo;

            // PR metadata
            const prNumber = run.pull_requests[0].number;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const headRef = pr.head.ref;   // e.g. feature/branch or forks' branch name
            const headSha = pr.head.sha;

            // Use the repo's default branch as the dispatch ref so the workflow file is guaranteed present
            const defaultBranch = (context.payload.repository && context.payload.repository.default_branch) ? context.payload.repository.default_branch : 'main';

            // Which workflow file to dispatch
            const debugWorkflow = process.env.DEBUG_WORKFLOW_FILE && process.env.DEBUG_WORKFLOW_FILE.trim().length
              ? process.env.DEBUG_WORKFLOW_FILE.trim()
              : process.env.DEFAULT_DEBUG_WORKFLOW_FILE;

            // Compose a PR ref that exists in the base repo regardless of forks
            // refs/pull/<num>/head = the PR's head commit
            const prRef = `refs/pull/${prNumber}/head`;

            // Kick off the debug workflow living on the default branch, passing PR context
            await github.rest.actions.createWorkflowDispatch({
              owner,
              repo,
              workflow_id: debugWorkflow,
              ref: defaultBranch,
              inputs: {
                pr_number: String(prNumber),
                target_ref: prRef,          // what the debug workflow should check out
                pr_head_ref: headRef,       // informational
                pr_head_sha: headSha,       // informational / optional verification
                debug_mode: 'true'
              }
            });

            // Leave a breadcrumb on the PR for humans
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body:
                `CI failed. Triggered **Codex Auto-Debug** from \`${defaultBranch}\` with ` +
                `**target_ref** \`${prRef}\` (head \`${headRef}@${headSha.slice(0,7)}\`).\n\n` +
                `You’ll see a new debug run under **Actions → Codex Auto-Debug**. ` +
                `If the failure is trivial (format/lint), the autofix job may push directly.`
            });
